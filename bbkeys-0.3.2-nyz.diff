diff -urN bbkeys-0.3.2/BaseDisplay.cc bbkeys-0.3.2-nyz/BaseDisplay.cc
--- bbkeys-0.3.2/BaseDisplay.cc	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/BaseDisplay.cc	Wed May 10 23:02:16 2000
@@ -1,5 +1,5 @@
 // BaseDisplay.cc for Blackbox - an X11 Window manager
-// Copyright (c) 1997 - 1999 Brad Hughes (bhughes@tcac.net)
+// Copyright (c) 1997 - 2000 Brad Hughes (bhughes@tcac.net)
 //
 // Permission is hereby granted, free of charge, to any person obtaining a
 // copy of this software and associated documentation files (the "Software"),
@@ -43,8 +43,12 @@
 #include "LinkedList.hh"
 #include "Timer.hh"
 
+#ifdef    DEBUG
+#  include "mem.h"
+#endif // DEBUG
+
 #ifdef    HAVE_FCNTL_H
-#  include <fcntl.h>  
+#  include <fcntl.h>
 #endif // HAVE_FCNTL_H
 
 #ifdef    HAVE_STDIO_H
@@ -54,7 +58,7 @@
 #ifdef    STDC_HEADERS
 #  include <stdlib.h>
 #  include <string.h>
-#endif // STDC_HEADERS 
+#endif // STDC_HEADERS
 
 #ifdef    HAVE_UNISTD_H
 #  include <sys/types.h>
@@ -66,11 +70,11 @@
 #endif // HAVE_SYS_SELECT_H
 
 #ifdef    HAVE_SIGNAL_H
-#  include <signal.h>  
+#  include <signal.h>
 #endif // HAVE_SIGNAL_H
 
 #ifdef    HAVE_SYS_SIGNAL_H
-#  include <sys/signal.h>
+// #  include <sys/signal.h>
 #endif // HAVE_SYS_SIGNAL_H
 
 #ifndef   SA_NODEFER
@@ -90,16 +94,24 @@
 // X error handler to handle any and all X errors while the application is
 // running
 static Bool internal_error = False;
-BaseDisplay *base_display;
+static Window last_bad_window = None;
 
+BaseDisplay *base_display;
+  
+#ifdef    DEBUG
 static int handleXErrors(Display *d, XErrorEvent *e) {
   char errtxt[128];
+
   XGetErrorText(d, e->error_code, errtxt, 128);
   fprintf(stderr, "%s:  X error: %s(%d) opcodes %d/%d\n"
-                  "  resource 0x%lx\n",
+	  "  resource 0x%lx\n",
           base_display->getApplicationName(), errtxt, e->error_code,
           e->request_code, e->minor_code, e->resourceid);
-
+#else // !DEBUG
+static int handleXErrors(Display *, XErrorEvent *e) {
+#endif // DEBUG
+  
+  if (e->error_code == BadWindow) last_bad_window = e->resourceid;
   if (internal_error) abort();
 
   return(False);
@@ -163,33 +175,40 @@
 
 
 BaseDisplay::BaseDisplay(char *app_name, char *dpy_name) {
+#ifdef    DEBUG
+  allocate(sizeof(BaseDisplay), "BaseDisplay.cc");
+#endif // DEBUG
+
   application_name = app_name;
 
   _startup = True;
   _shutdown = False;
   server_grabs = 0;
+  last_bad_window = None;
 
   ::base_display = this;
 
 #ifdef    HAVE_SIGACTION
   struct sigaction action;
 
-  action.sa_handler = signalhandler;    
+  action.sa_handler = signalhandler;
   action.sa_mask = sigset_t();
   action.sa_flags = SA_NOCLDSTOP | SA_NODEFER;
-    
+
   sigaction(SIGSEGV, &action, NULL);
   sigaction(SIGFPE, &action, NULL);
   sigaction(SIGTERM, &action, NULL);
   sigaction(SIGINT, &action, NULL);
   sigaction(SIGCHLD, &action, NULL);
   sigaction(SIGHUP, &action, NULL);
+  sigaction(SIGUSR1, &action, NULL);
   sigaction(SIGUSR2, &action, NULL);
 #else // !HAVE_SIGACTION
   signal(SIGSEGV, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGFPE, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGTERM, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGINT, (RETSIGTYPE (*)(int)) signalhandler);
+  signal(SIGUSR1, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGUSR2, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGHUP, (RETSIGTYPE (*)(int)) signalhandler);
   signal(SIGCHLD, (RETSIGTYPE (*)(int)) signalhandler);
@@ -215,7 +234,7 @@
 #else // !SHAPE
   shape.extensions = False;
 #endif // SHAPE
-  
+
   xa_wm_colormap_windows =
     XInternAtom(display, "WM_COLORMAP_WINDOWS", False);
   xa_wm_protocols = XInternAtom(display, "WM_PROTOCOLS", False);
@@ -224,32 +243,69 @@
   xa_wm_delete_window = XInternAtom(display, "WM_DELETE_WINDOW", False);
   xa_wm_take_focus = XInternAtom(display, "WM_TAKE_FOCUS", False);
   motif_wm_hints = XInternAtom(display, "_MOTIF_WM_HINTS", False);
+  
+  blackbox_hints = XInternAtom(display, "_BLACKBOX_HINTS", False);
+  blackbox_attributes = XInternAtom(display, "_BLACKBOX_ATTRIBUTES", False);
+  blackbox_change_attributes =
+    XInternAtom(display, "_BLACKBOX_CHANGE_ATTRIBUTES", False);
+
+  blackbox_structure_messages =
+    XInternAtom(display, "_BLACKBOX_STRUCTURE_MESSAGES", False);
+  blackbox_notify_startup =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_STARTUP", False);
+  blackbox_notify_window_add =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WINDOW_ADD", False);
+  blackbox_notify_window_del =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WINDOW_DEL", False);
+  blackbox_notify_current_workspace =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_CURRENT_WORKSPACE", False);
+  blackbox_notify_workspace_count =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WORKSPACE_COUNT", False);
+  blackbox_notify_window_focus =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WINDOW_FOCUS", False);
+  blackbox_notify_window_raise =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WINDOW_RAISE", False);
+  blackbox_notify_window_lower =
+    XInternAtom(display, "_BLACKBOX_NOTIFY_WINDOW_LOWER", False);
+
+  blackbox_change_workspace= XInternAtom(display, "_BLACKBOX_CHANGE_WORKSPACE", False);
+  blackbox_change_window_focus =
+    XInternAtom(display, "_BLACKBOX_CHANGE_WINDOW_FOCUS", False);
+  blackbox_cycle_window_focus =
+    XInternAtom(display, "_BLACKBOX_CYCLE_WINDOW_FOCUS", False);
 
-  net_hints = XInternAtom(display, "_NET_HINTS", False);
-  net_attributes = XInternAtom(display, "_NET_ATTRIBUTES", False);
-  net_change_attributes =
-    XInternAtom(display, "_NET_CHANGE_ATTRIBUTES", False);
-
-  net_structure_messages =
-    XInternAtom(display, "_NET_STRUCTURE_MESSAGES", False);
-  net_notify_startup =
-    XInternAtom(display, "_NET_NOTIFY_STARTUP", False);
-  net_notify_window_add =
-    XInternAtom(display, "_NET_NOTIFY_WINDOW_ADD", False);
-  net_notify_window_del =
-    XInternAtom(display, "_NET_NOTIFY_WINDOW_DEL", False);
-  net_notify_current_workspace =
-    XInternAtom(display, "_NET_NOTIFY_CURRENT_WORKSPACE", False);
-  net_notify_workspace_count =
-    XInternAtom(display, "_NET_NOTIFY_WORKSPACE_COUNT", False);
-  net_notify_window_focus =
-    XInternAtom(display, "_NET_NOTIFY_WINDOW_FOCUS", False);
-
-  net_change_workspace= XInternAtom(display, "_NET_CHANGE_WORKSPACE", False);
-  net_change_window_focus =
-    XInternAtom(display, "_NET_CHANGE_WINDOW_FOCUS", False);
-  net_cycle_window_focus =
-    XInternAtom(display, "_NET_CYCLE_WINDOW_FOCUS", False); 
+#ifdef    NEWWMSPEC
+  
+  net_supported = XInternAtom(display, "_NET_SUPPORTED", False);
+  net_client_list = XInternAtom(display, "_NET_CLIENT_LIST", False);
+  net_client_list_stacking = XInternAtom(display, "_NET_CLIENT_LIST_STACKING", False);
+  net_number_of_desktops = XInternAtom(display, "_NET_NUMBER_OF_DESKTOPS", False);
+  net_desktop_geometry = XInternAtom(display, "_NET_DESKTOP_GEOMETRY", False);
+  net_desktop_viewport = XInternAtom(display, "_NET_DESKTOP_VIEWPORT", False);
+  net_current_desktop = XInternAtom(display, "_NET_CURRENT_DESKTOP", False);
+  net_desktop_names = XInternAtom(display, "_NET_DESKTOP_NAMES", False);
+  net_active_window = XInternAtom(display, "_NET_ACTIVE_WINDOW", False);
+  net_workarea = XInternAtom(display, "_NET_WORKAREA", False);
+  net_supporting_wm_check = XInternAtom(display, "_NET_SUPPORTING_WM_CHECK", False);
+  net_virtual_roots = XInternAtom(display, "_NET_VIRTUAL_ROOTS", False);
+  
+  net_close_window = XInternAtom(display, "_NET_CLOSE_WINDOW", False);
+  net_wm_moveresize = XInternAtom(display, "_NET_WM_MOVERESIZE", False);
+  
+  net_properties = XInternAtom(display, "_NET_PROPERTIES", False);
+  net_wm_name = XInternAtom(display, "_NET_WM_NAME", False);
+  net_wm_desktop = XInternAtom(display, "_NET_WM_DESKTOP", False);
+  net_wm_window_type = XInternAtom(display, "_NET_WM_WINDOW_TYPE", False);
+  net_wm_state = XInternAtom(display, "_NET_WM_STATE", False);
+  net_wm_strut = XInternAtom(display, "_NET_WM_STRUT", False);
+  net_wm_icon_geometry = XInternAtom(display, "_NET_WM_ICON_GEOMETRY", False);
+  net_wm_icon = XInternAtom(display, "_NET_WM_ICON", False);
+  net_wm_pid = XInternAtom(display, "_NET_WM_PID", False);
+  net_wm_handled_icons = XInternAtom(display, "_NET_WM_HANDLED_ICONS", False);
+    
+  net_wm_ping = XInternAtom(display, "_NET_WM_PING", False);
+  
+#endif // NEWWMSPEC
   
   cursor.session = XCreateFontCursor(display, XC_left_ptr);
   cursor.move = XCreateFontCursor(display, XC_fleur);
@@ -270,13 +326,23 @@
 
 
 BaseDisplay::~BaseDisplay(void) {
-  while (screenInfoList->count())
-    delete screenInfoList->remove(0);
+#ifdef    DEBUG
+  deallocate(sizeof(BaseDisplay), "BaseDisplay.cc");
+#endif // DEBUG
+
+  while (screenInfoList->count()) {
+    ScreenInfo *si = screenInfoList->first();
+
+    screenInfoList->remove(si);
+    delete si;
+  }
+
   delete screenInfoList;
 
   // we don't create the BTimers, we don't delete them
   while (timerList->count())
     timerList->remove(0);
+
   delete timerList;
 
   XCloseDisplay(display);
@@ -287,16 +353,21 @@
   run();
 
   int xfd = ConnectionNumber(display);
-  time_t lastCheck = time(NULL);
 
   while ((! _shutdown) && (! internal_error)) {
     if (XPending(display)) {
-          XEvent e;
-          XNextEvent(display, &e);
-          process_event(&e);
-    } else if (time(NULL) - lastCheck > 10) {
-      CheckConfig();
-      lastCheck = time(NULL);
+      XEvent e;
+      XNextEvent(display, &e);
+
+      if (last_bad_window != None && e.xany.window == last_bad_window) {
+#ifdef    DEBUG
+      fprintf(stderr, "BaseDisplay::eventLoop(): "
+              "removing bad window from event queue\n");
+#endif // DEBUG
+      } else {
+        last_bad_window = None;
+        process_event(&e);
+      }
     } else {
       fd_set rfds;
       timeval now, tm, *timeout = (timeval *) 0;
@@ -351,7 +422,7 @@
           break;
 
         it.current()->fireTimeout();
-  
+
         // restart the current timer so that the start time is updated
         if (! it.current()->doOnce()) it.current()->start();
         else it.current()->stop();
@@ -361,13 +432,13 @@
 }
 
 
-Bool BaseDisplay::validateWindow(Window window) {  
+const Bool BaseDisplay::validateWindow(Window window) {
   XEvent event;
   if (XCheckTypedWindowEvent(display, window, DestroyNotify, &event)) {
     XPutBackEvent(display, &event);
 
     return False;
-  } 
+  }
 
   return True;
 }
@@ -376,8 +447,6 @@
 void BaseDisplay::grab(void) {
   if (! server_grabs++)
     XGrabServer(display);
-
-  XSync(display, False);
 }
 
 
@@ -410,16 +479,52 @@
 
 
 ScreenInfo::ScreenInfo(BaseDisplay *d, int num) {
+#ifdef    DEBUG
+  allocate(sizeof(ScreenInfo), "BaseDisplay.cc");
+#endif // DEBUG
+
   basedisplay = d;
   screen_number = num;
 
   root_window = RootWindow(basedisplay->getXDisplay(), screen_number);
-  visual = DefaultVisual(basedisplay->getXDisplay(), screen_number);
   depth = DefaultDepth(basedisplay->getXDisplay(), screen_number);
 
   width =
     WidthOfScreen(ScreenOfDisplay(basedisplay->getXDisplay(), screen_number));
   height =
     HeightOfScreen(ScreenOfDisplay(basedisplay->getXDisplay(), screen_number));
+
+  // search for a TrueColor Visual... if we can't find one... we will use the
+  // default visual for the screen
+  XVisualInfo vinfo_template, *vinfo_return;
+  int vinfo_nitems;
+
+  vinfo_template.screen = screen_number;
+  vinfo_template.c_class = TrueColor;
+
+  visual = (Visual *) 0;
+
+  if ((vinfo_return = XGetVisualInfo(basedisplay->getXDisplay(),
+                                     VisualScreenMask | VisualClassMask,
+                                     &vinfo_template, &vinfo_nitems)) &&
+      vinfo_nitems > 0) {
+    for (int i = 0; i < vinfo_nitems; i++) {
+      if (depth < (vinfo_return + i)->depth) {
+        depth = (vinfo_return + i)->depth;
+        visual = (vinfo_return + i)->visual;
+      }
+    }
+
+    XFree(vinfo_return);
+  }
+
+  if (! visual)
+    visual = DefaultVisual(basedisplay->getXDisplay(), screen_number);
 }
 
+
+#ifdef    DEBUG
+ScreenInfo::~ScreenInfo(void) {
+  deallocate(sizeof(ScreenInfo), "BaseDisplay.cc");
+}
+#endif // DEBUG
diff -urN bbkeys-0.3.2/BaseDisplay.hh bbkeys-0.3.2-nyz/BaseDisplay.hh
--- bbkeys-0.3.2/BaseDisplay.hh	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/BaseDisplay.hh	Fri May 12 01:50:17 2000
@@ -1,24 +1,24 @@
 // BaseDisplay.hh for Blackbox - an X11 Window manager
-// Copyright (c) 1997 - 1999 Brad Hughes (bhughes@tcac.net)
+// Copyright (c) 1997 - 2000 Brad Hughes (bhughes@tcac.net)
 //
 // Permission is hereby granted, free of charge, to any person obtaining a
 // copy of this software and associated documentation files (the "Software"),
 // to deal in the Software without restriction, including without limitation
 // the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the 
+// and/or sell copies of the Software, and to permit persons to whom the
 // Software is furnished to do so, subject to the following conditions:
 //
-// The above copyright notice and this permission notice shall be included in 
-// all copies or substantial portions of the Software. 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
 //
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 // DEALINGS IN THE SOFTWARE.
-  
+
 #ifndef   __BaseDisplay_hh
 #define   __BaseDisplay_hh
 
@@ -29,43 +29,49 @@
 class BaseDisplay;
 class ScreenInfo;
 
-#include "LinkedList.hh"     
+#include "LinkedList.hh"
 #include "Timer.hh"
 
-#define NETAttribShaded      (1l << 0)
-#define NETAttribMaxHoriz    (1l << 1)
-#define NETAttribMaxVert     (1l << 2)
-#define NETAttribOmnipresent (1l << 3)
-#define NETAttribWorkspace   (1l << 4)
-#define NETAttribStack       (1l << 5)
-#define NETAttribDecoration  (1l << 6)
-
-#define NETStackTop          (0)
-#define NETStackNormal       (1)
-#define NETStackBottom       (2)
-
-#define NETDecorNone         (0)
-#define NETDecorNormal	     (1)
-#define NETDecorTiny         (2)
-#define NETDecorTool         (3)
+#define AttribShaded      (1l << 0)
+#define AttribMaxHoriz    (1l << 1)
+#define AttribMaxVert     (1l << 2)
+#define AttribOmnipresent (1l << 3)
+#define AttribWorkspace   (1l << 4)
+#define AttribStack       (1l << 5)
+#define AttribDecoration  (1l << 6)
+
+#define StackTop          (0)
+#define StackNormal       (1)
+#define StackBottom       (2)
+
+#define DecorNone         (0)
+#define DecorNormal       (1)
+#define DecorTiny         (2)
+#define DecorTool         (3)
 
-typedef struct _net_hints {
+typedef struct _blackbox_hints {
   unsigned long flags, attrib, workspace, stack, decoration;
-} NetHints;
+} BlackboxHints;
 
-typedef struct _net_attributes {
+typedef struct _blackbox_attributes {
   unsigned long flags, attrib, workspace, stack;
   int premax_x, premax_y;
   unsigned int premax_w, premax_h;
-} NetAttributes;
+} BlackboxAttributes;
+
+#define PropBlackboxHintsElements      (5)
+#define PropBlackboxAttributesElements (8)
+
+#ifdef    NEWWMSPEC
+
 
-#define PropNetHintsElements	(5)
-#define PropNetAttributesElements (8)
+
+
+#endif // NEWWMSPEC
 
 
 class BaseDisplay {
 private:
-
   struct cursor {
     Cursor session, move, ll_angle, lr_angle;
   } cursor;
@@ -78,96 +84,217 @@
   Atom xa_wm_colormap_windows, xa_wm_protocols, xa_wm_state,
     xa_wm_delete_window, xa_wm_take_focus, xa_wm_change_state,
     motif_wm_hints;
-
+    
   // NETAttributes
-  Atom net_attributes, net_change_attributes, net_hints;
+  Atom blackbox_attributes, blackbox_change_attributes, blackbox_hints;
 
   // NETStructureMessages
-  Atom net_structure_messages, net_notify_startup,
-    net_notify_window_add, net_notify_window_del,
-    net_notify_window_focus, net_notify_current_workspace,
-    net_notify_workspace_count;
+  Atom blackbox_structure_messages, blackbox_notify_startup,
+    blackbox_notify_window_add, blackbox_notify_window_del,
+    blackbox_notify_window_focus, blackbox_notify_current_workspace,
+    blackbox_notify_workspace_count, blackbox_notify_window_raise,
+    blackbox_notify_window_lower;
 
   // message_types for client -> wm messages
-  Atom net_change_workspace, net_change_window_focus,
-    net_cycle_window_focus;
-
+  Atom blackbox_change_workspace, blackbox_change_window_focus,
+    blackbox_cycle_window_focus;
+  
+#ifdef    NEWWMSPEC
+  
+  // root window properties
+  Atom net_supported, net_client_list, net_client_list_stacking,
+    net_number_of_desktops, net_desktop_geometry, net_desktop_viewport,
+    net_current_desktop, net_desktop_names, net_active_window, net_workarea,
+    net_supporting_wm_check, net_virtual_roots;
+  
+  // root window messages
+  Atom net_close_window, net_wm_moveresize;
+  
+  // application window properties
+  Atom net_properties, net_wm_name, net_wm_desktop, net_wm_window_type,
+    net_wm_state, net_wm_strut, net_wm_icon_geometry, net_wm_icon, net_wm_pid,
+    net_wm_handled_icons;
+  
+  // application protocols
+  Atom net_wm_ping;
+    
+#endif // NEWWMSPEC
+  
   Bool _startup, _shutdown;
   Display *display;
-
   LinkedList<ScreenInfo> *screenInfoList;
   LinkedList<BTimer> *timerList;
 
   char *display_name, *application_name;
   int number_of_screens, server_grabs, colors_per_channel;
-  bool configuring;
 
 
 protected:
   // pure virtual function... you must override this
   virtual void process_event(XEvent *) = 0;
-  virtual void CheckConfig(void) = 0;
-  
+
+
 public:
   BaseDisplay(char *, char * = 0);
   virtual ~BaseDisplay(void);
 
-  inline Atom getWMChangeStateAtom(void) { return xa_wm_change_state; }
-  inline Atom getWMStateAtom(void) { return xa_wm_state; }
-  inline Atom getWMDeleteAtom(void) { return xa_wm_delete_window; }
-  inline Atom getWMProtocolsAtom(void) { return xa_wm_protocols; }
-  inline Atom getWMFocusAtom(void) { return xa_wm_take_focus; }
-  inline Atom getWMColormapAtom(void) { return xa_wm_colormap_windows; }
-  inline Atom getMotifWMHintsAtom(void) { return motif_wm_hints; }
-
+  inline const Atom &getWMChangeStateAtom(void) const
+    { return xa_wm_change_state; }
+  inline const Atom &getWMStateAtom(void) const
+    { return xa_wm_state; }
+  inline const Atom &getWMDeleteAtom(void) const
+    { return xa_wm_delete_window; }
+  inline const Atom &getWMProtocolsAtom(void) const
+    { return xa_wm_protocols; }
+  inline const Atom &getWMTakeFocusAtom(void) const
+    { return xa_wm_take_focus; }
+  inline const Atom &getWMColormapAtom(void) const
+    { return xa_wm_colormap_windows; }
+  inline const Atom &getMotifWMHintsAtom(void) const
+    { return motif_wm_hints; }
+  
   // this atom is for normal app->WM hints about decorations, stacking,
   // starting workspace etc...
-  inline Atom getNETHintsAtom(void) { return net_hints;}
+  inline const Atom &getBlackboxHintsAtom(void) const
+    { return blackbox_hints;}
 
   // these atoms are for normal app->WM interaction beyond the scope of the
   // ICCCM...
-  inline Atom getNETAttributesAtom(void) { return net_attributes; }
-  inline Atom getNETChangeAttributesAtom(void)
-    { return net_change_attributes; }
-  
+  inline const Atom &getBlackboxAttributesAtom(void) const
+    { return blackbox_attributes; }
+  inline const Atom &getBlackboxChangeAttributesAtom(void) const
+    { return blackbox_change_attributes; }
+
   // these atoms are for window->WM interaction, with more control and
   // information on window "structure"... common examples are
   // notifying apps when windows are raised/lowered... when the user changes
   // workspaces... i.e. "pager talk"
-  inline Atom getNETStructureMessagesAtom(void)
-    { return net_structure_messages; }
+  inline const Atom &getBlackboxStructureMessagesAtom(void) const
+    { return blackbox_structure_messages; }
 
   // *Notify* portions of the NETStructureMessages protocol
-  inline Atom getNETNotifyStartupAtom(void) { return net_notify_startup; }
-  inline Atom getNETNotifyWindowAddAtom(void) { return net_notify_window_add; }
-  inline Atom getNETNotifyWindowDelAtom(void) { return net_notify_window_del; }
-  inline Atom getNETNotifyWindowFocusAtom(void)
-    { return net_notify_window_focus; }
-  inline Atom getNETNotifyCurrentWorkspaceAtom(void)
-    { return net_notify_current_workspace; }
-  inline Atom getNETNotifyWorkspaceCountAtom(void)
-    { return net_notify_workspace_count; }
+  inline const Atom &getBlackboxNotifyStartupAtom(void) const
+    { return blackbox_notify_startup; }
+  inline const Atom &getBlackboxNotifyWindowAddAtom(void) const
+    { return blackbox_notify_window_add; }
+  inline const Atom &getBlackboxNotifyWindowDelAtom(void) const
+    { return blackbox_notify_window_del; }
+  inline const Atom &getBlackboxNotifyWindowFocusAtom(void) const
+    { return blackbox_notify_window_focus; }
+  inline const Atom &getBlackboxNotifyCurrentWorkspaceAtom(void) const
+    { return blackbox_notify_current_workspace; }
+  inline const Atom &getBlackboxNotifyWorkspaceCountAtom(void) const
+    { return blackbox_notify_workspace_count; }
+  inline const Atom &getBlackboxNotifyWindowRaiseAtom(void) const
+    { return blackbox_notify_window_raise; }
+  inline const Atom &getBlackboxNotifyWindowLowerAtom(void) const
+    { return blackbox_notify_window_lower; }
 
   // atoms to change that request changes to the desktop environment during
   // runtime... these messages can be sent by any client... as the sending
   // client window id is not included in the ClientMessage event...
-  inline Atom getNETChangeWorkspaceAtom(void) { return net_change_workspace; }
-  inline Atom getNETChangeWindowFocusAtom(void)
-    { return net_change_window_focus; }
-  inline Atom getNETCycleWindowFocusAtom(void)
-    { return net_cycle_window_focus; }
-
+  inline const Atom &getBlackboxChangeWorkspaceAtom(void) const
+    { return blackbox_change_workspace; }
+  inline const Atom &getBlackboxChangeWindowFocusAtom(void) const
+    { return blackbox_change_window_focus; }
+  inline const Atom &getBlackboxCycleWindowFocusAtom(void) const
+    { return blackbox_cycle_window_focus; }
+  
+#ifdef    NEWWMSPEC
+  
+  // root window properties
+  inline const Atom &getNETSupportedAtom(void) const
+    { return net_supported; }
+  inline const Atom &getNETClientListAtom(void) const
+    { return net_client_list; }
+  inline const Atom &getNETClientListStackingAtom(void) const
+    { return net_client_list_stacking; }
+  inline const Atom &getNETNumberOfDesktopsAtom(void) const
+    { return net_number_of_desktops; }
+  inline const Atom &getNETDesktopGeometryAtom(void) const
+    { return net_desktop_geometry; }
+  inline const Atom &getNETDesktopViewportAtom(void) const
+    { return net_desktop_viewport; }
+  inline const Atom &getNETCurrentDesktopAtom(void) const
+    { return net_current_desktop; }
+  inline const Atom &getNETDesktopNamesAtom(void) const
+    { return net_desktop_names; }
+  inline const Atom &getNETActiveWindowAtom(void) const
+    { return net_active_window; }
+  inline const Atom &getNETWorkareaAtom(void) const
+    { return net_workarea; }
+  inline const Atom &getNETSupportingWMCheckAtom(void) const
+    { return net_supporting_wm_check; }
+  inline const Atom &getNETVirtualRootsAtom(void) const
+    { return net_virtual_roots; }
+  
+  // root window messages
+  inline const Atom &getNETCloseWindowAtom(void) const
+    { return net_close_window; }
+  inline const Atom &getNETWMMoveResizeAtom(void) const
+    { return net_wm_moveresize; }
+  
+  // application window properties
+  inline const Atom &getNETPropertiesAtom(void) const
+    { return net_properties; }
+  inline const Atom &getNETWMNameAtom(void) const
+    { return net_wm_name; }
+  inline const Atom &getNETWMDesktopAtom(void) const
+    { return net_wm_desktop; }
+  inline const Atom &getNETWMWindowTypeAtom(void) const
+    { return net_wm_window_type; }
+  inline const Atom &getNETWMStateAtom(void) const
+    { return net_wm_state; }
+  inline const Atom &getNETWMStrutAtom(void) const
+    { return net_wm_strut; }
+  inline const Atom &getNETWMIconGeometryAtom(void) const
+    { return net_wm_icon_geometry; }
+  inline const Atom &getNETWMIconAtom(void) const
+    { return net_wm_icon; }
+  inline const Atom &getNETWMPidAtom(void) const
+    { return net_wm_pid; }
+  inline const Atom &getNETWMHandledIconsAtom(void) const
+    { return net_wm_handled_icons; }
+  
+  // application protocols
+  inline const Atom &getNETWMPingAtom(void) const
+    { return net_wm_ping; }
+
+  /*
+    inline const Atom &getNET(void) const
+    { return net_; }
+    inline const Atom &getNET(void) const
+    { return net_; }
+    inline const Atom &getNET(void) const
+    { return net_; }
+    inline const Atom &getNET(void) const
+    { return net_; }
+    inline const Atom &getNET(void) const
+    { return net_; }
+    inline const Atom &getNET(void) const
+    { return net_; }
+  */
+  
+#endif // NEWWMSPEC
+  
   inline ScreenInfo *getScreenInfo(int s)
     { return (ScreenInfo *) screenInfoList->find(s); }
 
-  inline Bool hasShapeExtensions(void) { return shape.extensions; }
-  inline Bool doShutdown(void) { return _shutdown; }
-  inline Bool isStartup(void) { return _startup; }
-
-  inline Cursor getSessionCursor(void) { return cursor.session; }
-  inline Cursor getMoveCursor(void) { return cursor.move; }
-  inline Cursor getLowerLeftAngleCursor(void) { return cursor.ll_angle; }
-  inline Cursor getLowerRightAngleCursor(void) { return cursor.lr_angle; }
+  inline const Bool &hasShapeExtensions(void) const
+    { return shape.extensions; }
+  inline const Bool &doShutdown(void) const
+    { return _shutdown; }
+  inline const Bool &isStartup(void) const
+    { return _startup; }
+
+  inline const Cursor &getSessionCursor(void) const
+    { return cursor.session; }
+  inline const Cursor &getMoveCursor(void) const
+    { return cursor.move; }
+  inline const Cursor &getLowerLeftAngleCursor(void) const
+    { return cursor.ll_angle; }
+  inline const Cursor &getLowerRightAngleCursor(void) const
+    { return cursor.lr_angle; }
 
   inline Display *getXDisplay(void) { return display; }
 
@@ -176,21 +303,21 @@
   inline const char *getApplicationName(void) const
     { return (const char *) application_name; }
 
-  inline int getNumberOfScreens(void) { return number_of_screens; }
-  inline int getShapeEventBase(void) { return shape.event_basep; }
+  inline const int &getNumberOfScreens(void) const
+    { return number_of_screens; }
+  inline const int &getShapeEventBase(void) const
+    { return shape.event_basep; }
 
   inline void shutdown(void) { _shutdown = True; }
   inline void run(void) { _startup = _shutdown = False; }
 
-  Bool validateWindow(Window);
+  const Bool validateWindow(Window);
 
-  void grab(void);  
+  void grab(void);
   void ungrab(void);
   void eventLoop(void);
   void addTimer(BTimer *);
   void removeTimer(BTimer *);
-  void setConfiguring(bool n) { configuring = n; }
-  bool amConfiguring(void) {return configuring; }
 
   // another pure virtual... this is used to handle signals that BaseDisplay
   // doesn't understand itself
@@ -214,15 +341,19 @@
 public:
   ScreenInfo(BaseDisplay *, int);
 
+#ifdef    DEBUG
+  ~ScreenInfo(void);
+#endif // DEBUG
+
   inline BaseDisplay *getBaseDisplay(void) { return basedisplay; }
   inline Visual *getVisual(void) { return visual; }
-  inline Window getRootWindow(void) { return root_window; }
+  inline const Window &getRootWindow(void) const { return root_window; }
 
-  inline int getDepth(void) { return depth; }
-  inline int getScreenNumber(void) { return screen_number; }
+  inline const int &getDepth(void) const { return depth; }
+  inline const int &getScreenNumber(void) const { return screen_number; }
 
-  inline unsigned int getWidth(void) { return width; }
-  inline unsigned int getHeight(void) { return height; }
+  inline const unsigned int &getWidth(void) const { return width; }
+  inline const unsigned int &getHeight(void) const { return height; }
 };
 
 
diff -urN bbkeys-0.3.2/NETInterface.cc bbkeys-0.3.2-nyz/NETInterface.cc
--- bbkeys-0.3.2/NETInterface.cc	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/NETInterface.cc	Wed May 10 22:58:51 2000
@@ -32,33 +32,33 @@
 }
 
 void NETInterface::handleNETEvents(XEvent Event) {
-  if (Event.xclient.message_type==base->getNETStructureMessagesAtom()) {
-    if ((unsigned)Event.xclient.data.l[0]==base->getNETNotifyStartupAtom()) {
+  if (Event.xclient.message_type==base->getBlackboxStructureMessagesAtom()) {
+    if ((unsigned)Event.xclient.data.l[0]==base->getBlackboxNotifyStartupAtom()) {
       NETNotifyStartup();
       net_init=True;
     }
     else if ((unsigned)Event.xclient.data.l[0]==
-                                      base->getNETNotifyWindowAddAtom()) {
+                                      base->getBlackboxNotifyWindowAddAtom()) {
       NETNotifyWindowAdd(Event.xclient.data.l[1],Event.xclient.data.l[2]);
     }
     else if ((unsigned)Event.xclient.data.l[0]==
-                                      base->getNETNotifyWindowDelAtom()) {
+                                      base->getBlackboxNotifyWindowDelAtom()) {
       NETNotifyDel(Event.xclient.data.l[1]);
     }
     else if ((unsigned)Event.xclient.data.l[0]==
-                                      base->getNETAttributesAtom()) {
+                                      base->getBlackboxAttributesAtom()) {
       NETNotifyAttributes(Event.xclient.data.l[1]);
     }
     else if ((unsigned)Event.xclient.data.l[0]==
-                                      base->getNETNotifyWindowFocusAtom()){
+                                      base->getBlackboxNotifyWindowFocusAtom()){
       NETNotifyFocus(Event.xclient.data.l[1]);
     }
     if ((unsigned)Event.xclient.data.l[0]==
-                                   base->getNETNotifyCurrentWorkspaceAtom()){
+                                   base->getBlackboxNotifyCurrentWorkspaceAtom()){
       NETNotifyCurrentWorkspace(Event.xclient.data.l[1]);
     }
     else if ((unsigned)Event.xclient.data.l[0]==
-                                    base->getNETNotifyWorkspaceCountAtom()) {
+                                    base->getBlackboxNotifyWorkspaceCountAtom()) {
       NETNotifyWorkspaceCount(Event.xclient.data.l[1]);
     }
   }
diff -urN bbkeys-0.3.2/bbkeys.cc bbkeys-0.3.2-nyz/bbkeys.cc
--- bbkeys-0.3.2/bbkeys.cc	Sat Apr  8 14:35:56 2000
+++ bbkeys-0.3.2-nyz/bbkeys.cc	Wed May 10 22:58:51 2000
@@ -807,7 +807,7 @@
 	data = 0;
     }
 
-    wminterface->sendClientMessage(getNETCycleWindowFocusAtom(), data);
+    wminterface->sendClientMessage(getBlackboxCycleWindowFocusAtom(), data);
 
 }
 
@@ -1049,18 +1049,18 @@
 		     getArgc(), &sizehints, &wmhints, &classhints);
     Atom wmproto[2];
     wmproto[0] = wm_delete_window;
-    wmproto[1] = getNETStructureMessagesAtom();
+    wmproto[1] = getBlackboxStructureMessagesAtom();
     XSetWMProtocols(getXDisplay(), framewin, wmproto, 2);
 
     if (!decorated && !withdrawn) {
-	NetHints net_hints;
-	net_hints.decoration = NETDecorNone;
-	net_hints.attrib = NETAttribOmnipresent;
-	net_hints.flags = NETAttribDecoration | NETAttribOmnipresent;
-	XChangeProperty(getXDisplay(), framewin, getNETHintsAtom(),
-			getNETHintsAtom(), 32, PropModeReplace,
+	BlackboxHints net_hints;
+	net_hints.decoration = DecorNone;
+	net_hints.attrib = AttribOmnipresent;
+	net_hints.flags = AttribDecoration | AttribOmnipresent;
+	XChangeProperty(getXDisplay(), framewin, getBlackboxHintsAtom(),
+			getBlackboxHintsAtom(), 32, PropModeReplace,
 			(unsigned char *) &net_hints,
-			PropNetHintsElements);
+			PropBlackboxHintsElements);
     }
 
 
@@ -1317,33 +1317,33 @@
 			XEvent e;
 			e.xclient.type = ClientMessage;
 			e.xclient.message_type =
-			    getNETChangeAttributesAtom();
+			    getBlackboxChangeAttributesAtom();
 			e.xclient.window = focus_window;
 			e.xclient.format = 32;
-			e.xclient.data.l[0] = NETAttribShaded;
+			e.xclient.data.l[0] = AttribShaded;
 			e.xclient.data.l[2] = e.xclient.data.l[3] =
 			    e.xclient.data.l[4] = 0l;
 
 			Atom atom_return;
 			int foo;
 			unsigned long ulfoo, nitems;
-			NetAttributes *net;
+			BlackboxAttributes *net;
 			if (XGetWindowProperty(getXDisplay(), focus_window,
-					       getNETAttributesAtom(), 0l,
-					       PropNetAttributesElements,
+					       getBlackboxAttributesAtom(), 0l,
+					       PropBlackboxAttributesElements,
 					       False,
-					       getNETAttributesAtom(),
+					       getBlackboxAttributesAtom(),
 					       &atom_return, &foo, &nitems,
 					       &ulfoo,
 					       (unsigned char **) &net) ==
 			    Success && net
-			    && nitems == PropNetAttributesElements) {
+			    && nitems == PropBlackboxAttributesElements) {
 			    e.xclient.data.l[1] =
-				net->attrib ^ NETAttribShaded;
+				net->attrib ^ AttribShaded;
 
 			    XFree((void *) net);
 			} else
-			    e.xclient.data.l[1] = NETAttribShaded;
+			    e.xclient.data.l[1] = AttribShaded;
 
 			XSendEvent(getXDisplay(),
 				   getScreenInfo(0)->getRootWindow(),
@@ -1359,37 +1359,37 @@
 			XEvent e;
 			e.xclient.type = ClientMessage;
 			e.xclient.message_type =
-			    getNETChangeAttributesAtom();
+			    getBlackboxChangeAttributesAtom();
 			e.xclient.window = focus_window;
 			e.xclient.format = 32;
 			e.xclient.data.l[0] =
-			    NETAttribMaxHoriz | NETAttribMaxVert;
+			    AttribMaxHoriz | AttribMaxVert;
 			e.xclient.data.l[2] = e.xclient.data.l[3] =
 			    e.xclient.data.l[4] = 0l;
 
 			Atom atom_return;
 			int foo;
 			unsigned long ulfoo, nitems;
-			NetAttributes *net;
+			BlackboxAttributes *net;
 			if (XGetWindowProperty(getXDisplay(), focus_window,
-					       getNETAttributesAtom(), 0l,
-					       PropNetAttributesElements,
+					       getBlackboxAttributesAtom(), 0l,
+					       PropBlackboxAttributesElements,
 					       False,
-					       getNETAttributesAtom(),
+					       getBlackboxAttributesAtom(),
 					       &atom_return, &foo, &nitems,
 					       &ulfoo,
 					       (unsigned char **) &net) ==
 			    Success && net
-			    && nitems == PropNetAttributesElements) {
+			    && nitems == PropBlackboxAttributesElements) {
 			    e.xclient.data.l[1] =
 				net->
-				attrib ^ (NETAttribMaxHoriz |
-					  NETAttribMaxVert);
+				attrib ^ (AttribMaxHoriz |
+					  AttribMaxVert);
 
 			    XFree((void *) net);
 			} else
 			    e.xclient.data.l[1] =
-				(NETAttribMaxHoriz | NETAttribMaxVert);
+				(AttribMaxHoriz | AttribMaxVert);
 
 			XSendEvent(getXDisplay(),
 				   getScreenInfo(0)->getRootWindow(),
@@ -1405,33 +1405,33 @@
 			XEvent e;
 			e.xclient.type = ClientMessage;
 			e.xclient.message_type =
-			    getNETChangeAttributesAtom();
+			    getBlackboxChangeAttributesAtom();
 			e.xclient.window = focus_window;
 			e.xclient.format = 32;
-			e.xclient.data.l[0] = NETAttribOmnipresent;
+			e.xclient.data.l[0] = AttribOmnipresent;
 			e.xclient.data.l[2] = e.xclient.data.l[3] =
 			    e.xclient.data.l[4] = 0l;
 
 			Atom atom_return;
 			int foo;
 			unsigned long ulfoo, nitems;
-			NetAttributes *net;
+			BlackboxAttributes *net;
 			if (XGetWindowProperty(getXDisplay(), focus_window,
-					       getNETAttributesAtom(), 0l,
-					       PropNetAttributesElements,
+					       getBlackboxAttributesAtom(), 0l,
+					       PropBlackboxAttributesElements,
 					       False,
-					       getNETAttributesAtom(),
+					       getBlackboxAttributesAtom(),
 					       &atom_return, &foo, &nitems,
 					       &ulfoo,
 					       (unsigned char **) &net) ==
 			    Success && net
-			    && nitems == PropNetAttributesElements) {
+			    && nitems == PropBlackboxAttributesElements) {
 			    e.xclient.data.l[1] =
-				net->attrib ^ NETAttribOmnipresent;
+				net->attrib ^ AttribOmnipresent;
 
 			    XFree((void *) net);
 			} else
-			    e.xclient.data.l[1] = NETAttribOmnipresent;
+			    e.xclient.data.l[1] = AttribOmnipresent;
 
 			XSendEvent(getXDisplay(),
 				   getScreenInfo(0)->getRootWindow(),
@@ -1451,33 +1451,33 @@
 			XEvent e;
 			e.xclient.type = ClientMessage;
 			e.xclient.message_type =
-			    getNETChangeAttributesAtom();
+			    getBlackboxChangeAttributesAtom();
 			e.xclient.window = focus_window;
 			e.xclient.format = 32;
-			e.xclient.data.l[0] = NETAttribMaxVert;
+			e.xclient.data.l[0] = AttribMaxVert;
 			e.xclient.data.l[2] = e.xclient.data.l[3] =
 			    e.xclient.data.l[4] = 0l;
 
 			Atom atom_return;
 			int foo;
 			unsigned long ulfoo, nitems;
-			NetAttributes *net;
+			BlackboxAttributes *net;
 			if (XGetWindowProperty(getXDisplay(), focus_window,
-					       getNETAttributesAtom(), 0l,
-					       PropNetAttributesElements,
+					       getBlackboxAttributesAtom(), 0l,
+					       PropBlackboxAttributesElements,
 					       False,
-					       getNETAttributesAtom(),
+					       getBlackboxAttributesAtom(),
 					       &atom_return, &foo, &nitems,
 					       &ulfoo,
 					       (unsigned char **) &net) ==
 			    Success && net
-			    && nitems == PropNetAttributesElements) {
+			    && nitems == PropBlackboxAttributesElements) {
 			    e.xclient.data.l[1] =
-				net->attrib ^ (NETAttribMaxVert);
+				net->attrib ^ (AttribMaxVert);
 
 			    XFree((void *) net);
 			} else
-			    e.xclient.data.l[1] = (NETAttribMaxVert);
+			    e.xclient.data.l[1] = (AttribMaxVert);
 
 			XSendEvent(getXDisplay(),
 				   getScreenInfo(0)->getRootWindow(),
@@ -1493,33 +1493,33 @@
 			XEvent e;
 			e.xclient.type = ClientMessage;
 			e.xclient.message_type =
-			    getNETChangeAttributesAtom();
+			    getBlackboxChangeAttributesAtom();
 			e.xclient.window = focus_window;
 			e.xclient.format = 32;
-			e.xclient.data.l[0] = NETAttribMaxHoriz;
+			e.xclient.data.l[0] = AttribMaxHoriz;
 			e.xclient.data.l[2] = e.xclient.data.l[3] =
 			    e.xclient.data.l[4] = 0l;
 
 			Atom atom_return;
 			int foo;
 			unsigned long ulfoo, nitems;
-			NetAttributes *net;
+			BlackboxAttributes *net;
 			if (XGetWindowProperty(getXDisplay(), focus_window,
-					       getNETAttributesAtom(), 0l,
-					       PropNetAttributesElements,
+					       getBlackboxAttributesAtom(), 0l,
+					       PropBlackboxAttributesElements,
 					       False,
-					       getNETAttributesAtom(),
+					       getBlackboxAttributesAtom(),
 					       &atom_return, &foo, &nitems,
 					       &ulfoo,
 					       (unsigned char **) &net) ==
 			    Success && net
-			    && nitems == PropNetAttributesElements) {
+			    && nitems == PropBlackboxAttributesElements) {
 			    e.xclient.data.l[1] =
-				net->attrib ^ (NETAttribMaxHoriz);
+				net->attrib ^ (AttribMaxHoriz);
 
 			    XFree((void *) net);
 			} else
-			    e.xclient.data.l[1] = (NETAttribMaxHoriz);
+			    e.xclient.data.l[1] = (AttribMaxHoriz);
 
 			XSendEvent(getXDisplay(),
 				   getScreenInfo(0)->getRootWindow(),
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/Makefile bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile
--- bbkeys-0.3.2/bbkeysconf-1.2/Makefile	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile	Wed May 10 22:58:51 2000
@@ -14,8 +14,8 @@
 
 .SUFFIXES: .cc .o .hh .moc
 
-.cc.o: $(SOURCES)
-	$(CXX) $(CXXFLAGS) -c -o $@ $<
+.cc.o:
+	$(CXX) $(CXXFLAGS) $(CXXINC) -c -o $@ $<
 
 .hh.moc: $(MOCSRC)
 	$(MOC) $< -o $@
@@ -45,5 +45,4 @@
 	echo "Installing $(TARGET) in $(PREFIX)..."; \
     /usr/bin/install -s $(TARGET) $(PREFIX)/$(TARGET)
 
-gui.o: gui.cc gui.moc
-main.o: main.cc
+$(OBJECTS): $(SOURCES)
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/Makefile.orig bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile.orig
--- bbkeys-0.3.2/bbkeysconf-1.2/Makefile.orig	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile.orig	Sat Apr  8 12:15:50 2000
@@ -0,0 +1,49 @@
+CXX=		/usr/bin/g++
+QTDIR =		/usr/lib/qt2
+MOC =		/usr/bin/moc
+LIBS =		-L$(QTDIR)/lib -L/usr/lib -lqt
+CXXFLAGS =	-g -I/usr/include -I$(QTDIR)/include -I/usr/X11R6/include
+
+TARGET =	bbkeysconf
+PREFIX = /usr/local/bin
+OBJECTS =	gui.o main.o myapplication.o
+SOURCES = 	gui.cc main.cc myapplication.cc
+MOCSRC = 	gui.hh
+MOCOUT = 	gui.moc
+
+
+.SUFFIXES: .cc .o .hh .moc
+
+.cc.o: $(SOURCES)
+	$(CXX) $(CXXFLAGS) -c -o $@ $<
+
+.hh.moc: $(MOCSRC)
+	$(MOC) $< -o $@
+
+all: $(TARGET)
+
+$(TARGET): $(OBJECTS)
+	$(CXX) $(CXXFLAGS) $(LIBS) -o $(TARGET) $(OBJECTS)
+
+clean:
+	@echo "Cleaning up..." 
+	/bin/rm -f *.o *.moc $(TARGET)
+
+install: 
+	@echo "Looking for executable..." ; \
+    if ! test -x $(TARGET) ; then \
+       make; \
+    fi; \
+    if ! test -x $(TARGET) ; then \
+       exit; \
+    fi; \
+	echo "Checking existance of $(PREFIX)...."; \
+    if ! test -d $(PREFIX) ; then \
+       echo "Heyyyyy.  $(PREFIX) doesn't exist. Creating it...."; \
+       /usr/bin/install -d $(PREFIX); \
+    fi ; \
+	echo "Installing $(TARGET) in $(PREFIX)..."; \
+    /usr/bin/install -s $(TARGET) $(PREFIX)/$(TARGET)
+
+gui.o: gui.cc gui.moc
+main.o: main.cc
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/Makefile.rej bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile.rej
--- bbkeys-0.3.2/bbkeysconf-1.2/Makefile.rej	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/Makefile.rej	Wed May 10 22:58:51 2000
@@ -0,0 +1,18 @@
+***************
+*** 1,8 ****
+- CXX=		/usr/bin/g++
+- QTDIR =		/usr
+- MOC =		$(QTDIR)/bin/moc2
+- LIBS =		-L$(QTDIR)/lib/qt2 -L/usr/lib -lqt2
+- CXXFLAGS =	-g -I/usr/include -I$(QTDIR)/include/qt2
+  
+  TARGET =	bbkeysconf
+  PREFIX = /usr/local/bin
+--- 1,7 ----
++ CXX=		g++
++ MOC =		$(QTDIR)/bin/moc
++ LIBS =		-L$(QTDIR)/lib -L$(HOME)/src/qbth/lib -lqt -lqbthstyle
++ CXXINC =	-I/usr/X11R6/include -I$(QTDIR)/include -I$(HOME)/src/qbth/include
+  
+  TARGET =	bbkeysconf
+  PREFIX = /usr/local/bin
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/gui.cc bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.cc
--- bbkeys-0.3.2/bbkeysconf-1.2/gui.cc	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.cc	Wed May 10 22:58:51 2000
@@ -36,13 +36,10 @@
 FrontEnd::FrontEnd(QWidget * parent, const char *name)
 :QWidget(parent, name)
 {
-    const char *title = "gooey bbkeys Conflaguration Device";
-    const int height = 400;
-    const int width = 500;
+    const char *title = "bbkeysconf 1.2 - configuration for bbkeys";
     capturing = false;
 
     setCaption(title);
-    setFixedSize(width, height);
 
     // create the toplevel layout
     QBoxLayout *topLayout = new QVBoxLayout(this, 1);
@@ -74,14 +71,6 @@
     // Top label and separator
     QBoxLayout *vb = new QVBoxLayout(topLayout, 5);
 
-    QLabel *toplabel =
-	new QLabel("Welcome to Ye Olde BBKeys Conflagurator. "
-		   "We do hope your stay is pleasant...",
-		   this);
-    toplabel->setAlignment(QLabel::AlignHCenter | QLabel::AlignVCenter);
-    toplabel->setFont(QFont("helvetica", 12, 75));
-    vb->addWidget(toplabel);
-
     QFrame *sep1 = new QFrame(this);
     sep1->setFrameStyle(QFrame::HLine | QFrame::Raised);
     sep1->setLineWidth(1);
@@ -93,7 +82,7 @@
 
     QLabel *actionlabel = new QLabel(this);
     QString s;
-    s.sprintf("Action:");
+    s.sprintf("Action");
     actionlabel->setText(s);
     actionlabel->setAlignment(AlignCenter | AlignVCenter);
     hb->addWidget(actionlabel, 2);
@@ -128,7 +117,7 @@
     combobox->insertItem("Workspace12");
     hb->addWidget(combobox, 8);
 
-    cmdgrab = new QPushButton("Grab Key.", this);
+    cmdgrab = new QPushButton("Grab Key", this);
     connect(cmdgrab, SIGNAL(clicked()), this, SLOT(grabKey()));
 
     hb->addSpacing(5);
@@ -144,22 +133,20 @@
     listview->setAllColumnsShowFocus(true);
     listview->setMultiSelection(false);
     listview->setSorting(-1);
-    listview->addColumn(" Yer Key:  ", -1);
-    listview->addColumn(" Yer Modifier(s) ", -1);
-    listview->addColumn(" You wanna do WHAT with that???", 325);
+    listview->addColumn("Key");
+    listview->addColumn("Modifier(s)");
+    listview->addColumn("Action");
     listview->setColumnWidthMode(2, QListView::Maximum);
-    listview->setGeometry(10, 60, 500, 200);
-    listview->setMinimumSize(500, 180);
     connect(listview, SIGNAL(selectionChanged()), this,
 	    SLOT(listviewclick()));
 
     hb1->addWidget(listview);
 
     QBoxLayout *hb2 = new QHBoxLayout(topLayout);
-    rem = new QPushButton("Erm. Yeah, but not that one...", this);
+    rem = new QPushButton("Remove Selected", this);
     connect(rem, SIGNAL(clicked()), this, SLOT(nukeKeyGrab()));
 
-    remall = new QPushButton("To the dungeon with them all!!", this);
+    remall = new QPushButton("Remove All", this);
     connect(remall, SIGNAL(clicked()), this, SLOT(clearList()));
 
     hb2->addWidget(rem);
@@ -177,14 +164,14 @@
     QBoxLayout *h3 = new QHBoxLayout(topLayout);
 
     editframe =
-	new QGroupBox(2, Qt::Horizontal, "ExecCommand edit-foo", this);
+	new QGroupBox(2, Qt::Horizontal, "ExecCommand", this);
     editframe->setEnabled(false);
 
     txtcmd = new QLineEdit(editframe, "txtbox");
     txtcmd->setMaxLength(500);
     connect(txtcmd, SIGNAL(returnPressed()), this, SLOT(updatetext()));
 
-    cmdchangetext = new QPushButton("Yeah baybee!!", editframe);
+    cmdchangetext = new QPushButton("Apply", editframe);
     connect(cmdchangetext, SIGNAL(clicked()), this, SLOT(updatetext()));
 
     h3->addWidget(editframe);
@@ -193,11 +180,11 @@
     // closing buttons
     QHBox *hb3 = new QHBox(this);
 
-    finsave = new QPushButton("Hey, wow! Save this puppy!", hb3);
+    finsave = new QPushButton("Save .bbkeysrc", hb3);
     finsave->setMinimumWidth(200);
     connect(finsave, SIGNAL(clicked()), this, SLOT(save()));
 
-    finnosave = new QPushButton("Let me out!!", hb3);
+    finnosave = new QPushButton("Quit", hb3);
     finnosave->setMinimumWidth(200);
     connect(finnosave, SIGNAL(clicked()), qApp, SLOT(quit()));
 
@@ -206,7 +193,7 @@
     // ------------------------------------------------
     // throw in a status bar for good measure
     statusbar = new QLabel(this);
-    statusbar->setText("Weehee!!  Welcome to bbkeys configQt tool!");
+    statusbar->setText("Welcome to bbkeysconf.");
     statusbar->setFrameStyle(QFrame::Panel | QFrame::Sunken);
     // This widget will use all horizontal space, and have a fixed height.
     // put this into the class so we can send it messages
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/gui.cc.orig bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.cc.orig
--- bbkeys-0.3.2/bbkeysconf-1.2/gui.cc.orig	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.cc.orig	Sat Apr  8 12:15:50 2000
@@ -0,0 +1,597 @@
+// bbkeysConfigQT - front end implementation
+// Ryan Kelley <kelleyry@bc.edu>
+// vanRijn <j_dot_kasper@usa.net>
+// check http://movingparts.windsofstorm.net for more bbkeys info
+// licensed under the GPL
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <iostream.h>
+#include <fstream.h>
+
+#include <qapplication.h>
+#include <qmessagebox.h>
+#include <qlayout.h>
+#include <qstring.h>
+#include <qmenubar.h>
+#include <qfont.h>
+#include <qframe.h>
+#include <qlabel.h>
+#include <qvbox.h>
+#include <qhbox.h>
+#include <qpushbutton.h>
+#include <qevent.h>
+#include <qfiledialog.h>
+#include <qfile.h>
+#include <qtextstream.h>
+
+#include "gui.hh"
+
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+
+
+FrontEnd::FrontEnd(QWidget * parent, const char *name)
+:QWidget(parent, name)
+{
+    const char *title = "gooey bbkeys Conflaguration Device";
+    const int height = 400;
+    const int width = 500;
+    capturing = false;
+
+    setCaption(title);
+    setFixedSize(width, height);
+
+    // create the toplevel layout
+    QBoxLayout *topLayout = new QVBoxLayout(this, 1);
+
+    // create the menubar / add to the topLayout
+    menubar = new QMenuBar(this, "menu");
+
+    QPopupMenu *file = new QPopupMenu(menubar);
+    file->insertItem("Open", this, SLOT(open()));
+    file->insertItem("Save", this, SLOT(save()));
+    file->insertItem("Save As", this, SLOT(saveAs()));
+    file->insertSeparator();
+    file->insertItem("Exit", qApp, SLOT(quit()));
+
+    QPopupMenu *help = new QPopupMenu(menubar);
+    help->insertItem("About", this, SLOT(helpscreen()));
+
+    menubar->insertItem("File", file);
+    menubar->insertSeparator();
+    menubar->insertItem("Help", help);
+    menubar->setMidLineWidth(1);
+    menubar->setFrameStyle(QFrame::Box | QFrame::Sunken);
+    menubar->setLineWidth(1);
+    menubar->setSeparator(QMenuBar::InWindowsStyle);
+
+    topLayout->setMenuBar(menubar);
+
+    // ------------------------------------------------
+    // Top label and separator
+    QBoxLayout *vb = new QVBoxLayout(topLayout, 5);
+
+    QLabel *toplabel =
+	new QLabel("Welcome to Ye Olde BBKeys Conflagurator. "
+		   "We do hope your stay is pleasant...",
+		   this);
+    toplabel->setAlignment(QLabel::AlignHCenter | QLabel::AlignVCenter);
+    toplabel->setFont(QFont("helvetica", 12, 75));
+    vb->addWidget(toplabel);
+
+    QFrame *sep1 = new QFrame(this);
+    sep1->setFrameStyle(QFrame::HLine | QFrame::Raised);
+    sep1->setLineWidth(1);
+    vb->addWidget(sep1);
+
+    // ------------------------------------------------
+    // second box--contains combobox and grab button
+    QBoxLayout *hb = new QHBoxLayout(topLayout);
+
+    QLabel *actionlabel = new QLabel(this);
+    QString s;
+    s.sprintf("Action:");
+    actionlabel->setText(s);
+    actionlabel->setAlignment(AlignCenter | AlignVCenter);
+    hb->addWidget(actionlabel, 2);
+
+    combobox = new QComboBox(FALSE, this, "read-only combo");
+    // populate all our options, baybee!!
+    combobox->insertItem("Close");
+    combobox->insertItem("ExecCommand");
+    combobox->insertItem("Lower");
+    combobox->insertItem("MaximizeHorizontal");
+    combobox->insertItem("MaximizeVertical");
+    combobox->insertItem("MaximizeWindow");
+    combobox->insertItem("Minimize");
+    combobox->insertItem("NextWindow");
+    combobox->insertItem("NextWorkspace");
+    combobox->insertItem("PrevWindow");
+    combobox->insertItem("PrevWorkspace");
+    combobox->insertItem("Raise");
+    combobox->insertItem("ShadeWindow");
+    combobox->insertItem("StickWindow");
+    combobox->insertItem("Workspace1");
+    combobox->insertItem("Workspace2");
+    combobox->insertItem("Workspace3");
+    combobox->insertItem("Workspace4");
+    combobox->insertItem("Workspace5");
+    combobox->insertItem("Workspace6");
+    combobox->insertItem("Workspace7");
+    combobox->insertItem("Workspace8");
+    combobox->insertItem("Workspace9");
+    combobox->insertItem("Workspace10");
+    combobox->insertItem("Workspace11");
+    combobox->insertItem("Workspace12");
+    hb->addWidget(combobox, 8);
+
+    cmdgrab = new QPushButton("Grab Key.", this);
+    connect(cmdgrab, SIGNAL(clicked()), this, SLOT(grabKey()));
+
+    hb->addSpacing(5);
+    hb->addWidget(cmdgrab, 0);
+    hb->addSpacing(5);
+
+    // ------------------------------------------------
+    // time for the list view
+    QBoxLayout *hb1 = new QHBoxLayout(topLayout);
+
+    listview = new QListView(this);
+    listview->setRootIsDecorated(false);
+    listview->setAllColumnsShowFocus(true);
+    listview->setMultiSelection(false);
+    listview->setSorting(-1);
+    listview->addColumn(" Yer Key:  ", -1);
+    listview->addColumn(" Yer Modifier(s) ", -1);
+    listview->addColumn(" You wanna do WHAT with that???", 325);
+    listview->setColumnWidthMode(2, QListView::Maximum);
+    listview->setGeometry(10, 60, 500, 200);
+    listview->setMinimumSize(500, 180);
+    connect(listview, SIGNAL(selectionChanged()), this,
+	    SLOT(listviewclick()));
+
+    hb1->addWidget(listview);
+
+    QBoxLayout *hb2 = new QHBoxLayout(topLayout);
+    rem = new QPushButton("Erm. Yeah, but not that one...", this);
+    connect(rem, SIGNAL(clicked()), this, SLOT(nukeKeyGrab()));
+
+    remall = new QPushButton("To the dungeon with them all!!", this);
+    connect(remall, SIGNAL(clicked()), this, SLOT(clearList()));
+
+    hb2->addWidget(rem);
+    hb2->addWidget(remall);
+
+    // ------------------------------------------------
+    // separator below clist
+    QFrame *sep2 = new QFrame(this);
+    sep2->setFrameStyle(QFrame::HLine | QFrame::Raised);
+    sep2->setLineWidth(1);
+    topLayout->addWidget(sep2);
+
+    // ------------------------------------------------
+    // groupbox for editting ExecCommand stuff
+    QBoxLayout *h3 = new QHBoxLayout(topLayout);
+
+    editframe =
+	new QGroupBox(2, Qt::Horizontal, "ExecCommand edit-foo", this);
+    editframe->setEnabled(false);
+
+    txtcmd = new QLineEdit(editframe, "txtbox");
+    txtcmd->setMaxLength(500);
+    connect(txtcmd, SIGNAL(returnPressed()), this, SLOT(updatetext()));
+
+    cmdchangetext = new QPushButton("Yeah baybee!!", editframe);
+    connect(cmdchangetext, SIGNAL(clicked()), this, SLOT(updatetext()));
+
+    h3->addWidget(editframe);
+
+    // ------------------------------------------------
+    // closing buttons
+    QHBox *hb3 = new QHBox(this);
+
+    finsave = new QPushButton("Hey, wow! Save this puppy!", hb3);
+    finsave->setMinimumWidth(200);
+    connect(finsave, SIGNAL(clicked()), this, SLOT(save()));
+
+    finnosave = new QPushButton("Let me out!!", hb3);
+    finnosave->setMinimumWidth(200);
+    connect(finnosave, SIGNAL(clicked()), qApp, SLOT(quit()));
+
+    topLayout->addWidget(hb3);
+
+    // ------------------------------------------------
+    // throw in a status bar for good measure
+    statusbar = new QLabel(this);
+    statusbar->setText("Weehee!!  Welcome to bbkeys configQt tool!");
+    statusbar->setFrameStyle(QFrame::Panel | QFrame::Sunken);
+    // This widget will use all horizontal space, and have a fixed height.
+    // put this into the class so we can send it messages
+    topLayout->addWidget(statusbar);
+
+    // ------------------------------------------------
+    // done constructing our window.  Now to the real work. =:)
+
+    rcfile = getenv("HOME");
+    rcfile.append("/.bbkeysrc");
+
+    readFile();
+}
+
+FrontEnd::~FrontEnd()
+{
+    delete menubar;
+    delete statusbar;
+    delete combobox;
+    delete listview;
+}
+
+// SLOTS
+void FrontEnd::helpscreen()
+{
+    QMessageBox::about(this, "bbkeys configuration utility",
+		       "<p>Weehee!!  Strap on yer hip-huggers, baybee!!</p>"
+		       "<p>This here is a little honey of an application "
+		       "that I wrote to help configure bbkeys (a keybinding "
+		       "application for "
+		       "<a href='http://blackbox.alug.org'>"
+		       "blackbox).</a></p>"
+		       "<p>For more information, please visit "
+		       "<a href='http://movingparts.windsofstorm.net'>"
+		       "http://movingparts.windsofstorm.net</a>."
+		       "Thanks y'all!!!</p>");
+}
+
+void FrontEnd::updatetext(void)
+{
+    QListViewItem *item = listview->selectedItem();
+
+    if (item) {
+	QString s;
+	s.sprintf("ExecCommand {%s}",
+		  (const char *) txtcmd->text().simplifyWhiteSpace());
+	item->setText(2, s);
+	grablist.remove(item);
+	grablist.append(item);
+
+	statusbar->
+	    setText("Updated ExecCommand. Better watch it, pallie.");
+    }
+}
+
+void FrontEnd::listviewclick(void)
+{
+    QListViewItem *item = listview->selectedItem();
+
+    if (item) {
+	QString s = item->text(2);
+	int sB = 0, sE = 0;
+	if (s.contains("ExecCommand", false)) {
+	    editframe->setEnabled(true);
+	    sB = s.find('{', 0) + 1;
+	    sE = s.find('}', sB - 1);
+	    txtcmd->setText(s.mid(sB, sE - sB));
+	    txtcmd->setCursorPosition(0);
+	    txtcmd->setEnabled(true);
+	    cmdchangetext->setEnabled(true);
+	} else {
+	    editframe->setEnabled(false);
+	    txtcmd->setText("");
+	    txtcmd->setEnabled(false);
+	    cmdchangetext->setEnabled(false);
+	}
+    }
+}
+
+void FrontEnd::clearList(void)
+{
+    listview->clear();
+    grablist.clear();
+    editframe->setEnabled(false);
+    txtcmd->setText("");
+    txtcmd->setEnabled(false);
+    cmdchangetext->setEnabled(false);
+    statusbar->setText("List cleared. Carry on, Pilgrim...");
+}
+
+void FrontEnd::nukeKeyGrab()
+{
+    QListViewItem *item = listview->selectedItem();
+
+    if (item) {
+	listview->removeItem(item);
+	grablist.remove(item);
+    }
+    editframe->setEnabled(false);
+    txtcmd->setText("");
+    txtcmd->setEnabled(false);
+    cmdchangetext->setEnabled(false);
+    statusbar->setText("Okey dokey. That one went to /dev/null...");
+}
+
+void FrontEnd::grabKey()
+{
+    if (!capturing) {
+	capturing = true;
+	cmdgrab->setText("Cancel");
+	statusbar->setText
+	    ("Press your desired shortcut key(s) or "
+	     "Cancel to stop capturing.");
+	editframe->setEnabled(false);
+	txtcmd->setText("");
+	txtcmd->setEnabled(false);
+	cmdchangetext->setEnabled(false);
+
+	listview->setEnabled(false);
+	combobox->setEnabled(false);
+	menubar->hide();
+
+	rem->setEnabled(false);
+	remall->setEnabled(false);
+	finsave->setEnabled(false);
+	finnosave->setEnabled(false);
+	//this->grabKeyboard();
+
+    } else {
+	// we should only hit this code when the user hits "Cancel"
+	// the actual grabbing is done in keyPressEvent, baybee
+
+	capturing = false;
+	cmdgrab->setText("Grab Key");
+	statusbar->
+	    setText("Alllllllrighty then. Don't toy with me, man!!!");
+
+	listview->setEnabled(true);
+	combobox->setEnabled(true);
+	menubar->show();
+
+	rem->setEnabled(true);
+	remall->setEnabled(true);
+	finsave->setEnabled(true);
+	finnosave->setEnabled(true);
+	//this->releaseKeyboard();
+    }
+}
+
+//void FrontEnd::keyPressEvent(QKeyEvent * k)
+void FrontEnd::captureKeygrab(XEvent * e)
+{
+    if (!capturing)
+	return;
+    if ((XKeycodeToKeysym(qt_xdisplay(), e->xkey.keycode, 0)
+	 >= XK_Shift_L
+	 && XKeycodeToKeysym(qt_xdisplay(), e->xkey.keycode,
+			     0) <= XK_Hyper_R) ||
+	(XKeycodeToKeysym(qt_xdisplay(), e->xkey.keycode, 0)
+	 == XK_Num_Lock))
+
+	return;
+
+    QString action = combobox->currentText();
+    if (action.contains("ExecCommand", false)) {
+	action.append(" {Wahoo! Edit me baybee!}");
+    }
+
+    QString mods;
+    switch (e->xkey.state) {
+    case ShiftMask:
+	mods = "Shift";
+	break;
+    case ControlMask:
+	mods = "Control";
+	break;
+    case Mod1Mask:
+	mods = "Mod1";
+	break;
+    case Mod2Mask:
+	mods = "Mod2";
+	break;
+    case Mod3Mask:
+	mods = "Mod3";
+	break;
+    case Mod4Mask:
+	mods = "Mod4";
+	break;
+    case Mod5Mask:
+	mods = "Mod5";
+	break;
+
+	/* I know, it's not all the combinations, but hey... */
+    case ControlMask | ShiftMask:
+	mods = "Control+Shift";
+	break;
+    case ControlMask | Mod1Mask:
+	mods = "Control+Mod1";
+	break;
+    case Mod1Mask | ShiftMask:
+	mods = "Mod1+Shift";
+	break;
+    case ControlMask | ShiftMask | Mod1Mask:
+	mods = "Control+Shift+Mod1";
+	break;
+
+    default:
+	mods = "None";
+	break;
+    }
+
+    QString
+	w = XKeysymToString(XKeycodeToKeysym(qt_xdisplay(),
+					     e->xkey.keycode, 0));
+
+
+    /* Okay, we know what they want, but we need to make sure that they
+     * don't already have something in the listview for either this action
+     * or this key+modifiers.  If so, replace it....
+     */
+
+    bool gottaGoober = false;
+
+    for (QListViewItem * it = listview->firstChild();
+	 it; it = it->nextSibling()) {
+	if ((it->text(0) == w && it->text(1) == mods)
+	    || it->text(2) == action) {
+	    gottaGoober = true;
+	    listview->removeItem(it);
+	    grablist.remove(it);
+	}
+    }
+
+    grablist.append(new QListViewItem(listview, w, mods, action));
+    listview->setCurrentItem(grablist.current());
+    listview->ensureItemVisible(grablist.current());
+
+    if (gottaGoober) {
+	statusbar->setText("Found duplicate keys or action. Fixed.");
+    } else {
+	statusbar->setText("Yeah, baybee!! Groove with it, baybee!!");
+    }
+
+    capturing = false;
+    cmdgrab->setText("Grab Key");
+
+    listview->setEnabled(true);
+    combobox->setEnabled(true);
+    menubar->show();
+
+    rem->setEnabled(true);
+    remall->setEnabled(true);
+    finsave->setEnabled(true);
+    finnosave->setEnabled(true);
+    //this->releaseKeyboard();
+
+}
+
+void FrontEnd::open()
+{
+    QString temp = rcfile;
+
+    rcfile = QFileDialog::getOpenFileName();
+
+    if (rcfile) {
+	readFile();
+	statusbar->setText("File opened. Let the games begin, baybee.");
+    } else {
+	statusbar->setText("Not opened.");
+	rcfile = temp;
+    }
+}
+
+void FrontEnd::save()
+{
+    writeFile();
+    statusbar->setText("File saved.");
+    exit(0);
+}
+
+void FrontEnd::saveAs()
+{
+    QString temp = rcfile;
+
+    rcfile = QFileDialog::getSaveFileName();
+
+    if (rcfile)
+	save();
+    else {
+	statusbar->setText("Not saved.");
+	rcfile = temp;
+    }
+}
+
+// PRIVATE FUNCTIONS UNFIT FOR HUMAN CONSUMPTION
+void FrontEnd::readFile()
+{
+    if (!grablist.isEmpty()) {
+	listview->clear();
+	grablist.clear();
+    }
+
+    QFile f(rcfile);
+    if (f.open(IO_ReadOnly)) {	// file opened successfully
+	QTextStream t(&f);	// use a text stream
+	QString s;
+	while (!t.eof()) {	// until end of file...
+	    s = t.readLine();	// line of text excluding '\n'
+	    s = s.simplifyWhiteSpace();
+	    if (s.left(4) == '#' || !s.contains("WithModifier", false)) {
+		continue;
+	    }
+	    QString key, mods, action, cmd;
+	    int keyB, modsB, actionB, cmdB;
+	    int keyE, modsE, actionE, cmdE;
+
+	    keyB = s.find('(', 0, true);
+	    keyE = s.find(')', keyB, true);
+	    modsB = s.find('(', keyE, true);
+	    modsE = s.find(')', modsB, true);
+	    actionB = s.find('(', modsE, true);
+	    actionE = s.find(')', actionB, true);
+
+	    key = s.mid(keyB + 1, keyE - keyB - 1);
+	    if (key.contains("iso_left_tab", false))
+		key = "Tab";
+	    mods = s.mid(modsB + 1, modsE - modsB - 1);
+	    action = s.mid(actionB + 1, actionE - actionB - 1);
+
+	    /* if we're supposed to having an execCommand and we do have
+	     * something to put into it                                 */
+	    if (s.contains("ExecCommand", false)) {
+		cmdB = s.find('(', actionE, true);
+		cmdE = s.find(')', cmdB, true);
+		if (cmdB && cmdE) {
+		    cmd = s.mid(cmdB + 1, cmdE - cmdB - 1);
+		} else {
+		    cmd = "Error in ExecCommand syntax";
+		}
+		action.append(" {");
+		action.append(cmd);
+		action.append("}");
+	    }
+	    if (!key.isEmpty() && !mods.isEmpty()
+		&& !action.isEmpty()) {
+		grablist.
+		    append(new QListViewItem(listview, key, mods, action));
+	    }
+	}
+	f.close();
+	listview->setSorting(0, true);
+    } else {
+	QString stat;
+	stat.sprintf
+	    ("Hey now. I can't seem to open %s! Ya hate to see that!",
+	     (const char *) rcfile);
+	statusbar->setText(stat);
+
+    }
+}
+
+void FrontEnd::writeFile()
+{
+    ofstream out(rcfile);
+
+    for (QListViewItem * it = listview->firstChild();
+	 it; it = it->nextSibling()) {
+	if (!it->text(2).contains("ExecCommand", false)) {
+	    out << "KeyToGrab(" << it->text(0) <<
+		"), WithModifier(" << it->text(1) <<
+		"), WithAction(" << it->text(2) << ")" << endl;
+	} else {
+	    QString s = it->text(2);
+	    int sB = 0, sE = 0;
+	    sB = s.find('{', 0) + 1;
+	    sE = s.find('}', sB);
+	    out << "KeyToGrab(" << it->text(0) <<
+		"), WithModifier(" << it->text(1) <<
+		"), WithAction(ExecCommand" <<
+		"), DoThis(" << s.mid(sB, sE - sB) << ")" << endl;
+	}
+    }
+
+    out.close();
+
+}
+
+#include "gui.moc"
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/gui.moc bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.moc
--- bbkeys-0.3.2/bbkeysconf-1.2/gui.moc	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/gui.moc	Wed May 10 22:58:51 2000
@@ -0,0 +1,99 @@
+/****************************************************************************
+** FrontEnd meta object code from reading C++ file 'gui.hh'
+**
+** Created: Sat Apr 29 20:35:42 2000
+**      by: The Qt MOC ($Id$)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_FrontEnd
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 7
+#elif Q_MOC_OUTPUT_REVISION != 7
+#error "Moc format conflict - please regenerate all moc files"
+#endif
+
+#include "gui.hh"
+#include <qmetaobject.h>
+#include <qapplication.h>
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &
+#endif
+
+
+const char *FrontEnd::className() const
+{
+    return "FrontEnd";
+}
+
+QMetaObject *FrontEnd::metaObj = 0;
+
+void FrontEnd::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QWidget::className(), "QWidget") != 0 )
+	badSuperclassWarning("FrontEnd","QWidget");
+    (void) staticMetaObject();
+}
+
+QString FrontEnd::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)->translate("FrontEnd",s);
+}
+
+QMetaObject* FrontEnd::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QWidget::staticMetaObject();
+    typedef void(FrontEnd::*m1_t0)();
+    typedef void(FrontEnd::*m1_t1)();
+    typedef void(FrontEnd::*m1_t2)();
+    typedef void(FrontEnd::*m1_t3)();
+    typedef void(FrontEnd::*m1_t4)();
+    typedef void(FrontEnd::*m1_t5)();
+    typedef void(FrontEnd::*m1_t6)();
+    typedef void(FrontEnd::*m1_t7)();
+    typedef void(FrontEnd::*m1_t8)();
+    m1_t0 v1_0 = Q_AMPERSAND FrontEnd::updatetext;
+    m1_t1 v1_1 = Q_AMPERSAND FrontEnd::grabKey;
+    m1_t2 v1_2 = Q_AMPERSAND FrontEnd::nukeKeyGrab;
+    m1_t3 v1_3 = Q_AMPERSAND FrontEnd::clearList;
+    m1_t4 v1_4 = Q_AMPERSAND FrontEnd::open;
+    m1_t5 v1_5 = Q_AMPERSAND FrontEnd::save;
+    m1_t6 v1_6 = Q_AMPERSAND FrontEnd::saveAs;
+    m1_t7 v1_7 = Q_AMPERSAND FrontEnd::listviewclick;
+    m1_t8 v1_8 = Q_AMPERSAND FrontEnd::helpscreen;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(9);
+    slot_tbl[0].name = "updatetext()";
+    slot_tbl[1].name = "grabKey()";
+    slot_tbl[2].name = "nukeKeyGrab()";
+    slot_tbl[3].name = "clearList()";
+    slot_tbl[4].name = "open()";
+    slot_tbl[5].name = "save()";
+    slot_tbl[6].name = "saveAs()";
+    slot_tbl[7].name = "listviewclick()";
+    slot_tbl[8].name = "helpscreen()";
+    slot_tbl[0].ptr = *((QMember*)&v1_0);
+    slot_tbl[1].ptr = *((QMember*)&v1_1);
+    slot_tbl[2].ptr = *((QMember*)&v1_2);
+    slot_tbl[3].ptr = *((QMember*)&v1_3);
+    slot_tbl[4].ptr = *((QMember*)&v1_4);
+    slot_tbl[5].ptr = *((QMember*)&v1_5);
+    slot_tbl[6].ptr = *((QMember*)&v1_6);
+    slot_tbl[7].ptr = *((QMember*)&v1_7);
+    slot_tbl[8].ptr = *((QMember*)&v1_8);
+    metaObj = QMetaObject::new_metaobject(
+	"FrontEnd", "QWidget",
+	slot_tbl, 9,
+	0, 0,
+	0, 0,
+	0, 0,
+	0, 0 );
+    return metaObj;
+}
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/main.cc bbkeys-0.3.2-nyz/bbkeysconf-1.2/main.cc
--- bbkeys-0.3.2/bbkeysconf-1.2/main.cc	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/main.cc	Wed May 10 22:58:51 2000
@@ -5,13 +5,13 @@
 // licensed under the GPL
 
 #include "myapplication.hh"
-#include <qwindowsstyle.h>
+#include <qbthstyle.h>
 
 #include "gui.hh"
 
 int main( int argc, char **argv )
 {
-  QApplication::setStyle( new QWindowsStyle());
+  QApplication::setStyle( new QbthStyle());
   MyApplication bbkeysCfg( argc, argv );
 
   FrontEnd *fe = new FrontEnd( 0, "FrontEnd" );
diff -urN bbkeys-0.3.2/bbkeysconf-1.2/main.cc.orig bbkeys-0.3.2-nyz/bbkeysconf-1.2/main.cc.orig
--- bbkeys-0.3.2/bbkeysconf-1.2/main.cc.orig	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/bbkeysconf-1.2/main.cc.orig	Sat Apr  8 12:15:50 2000
@@ -0,0 +1,24 @@
+// QT Frontend for the BBkeys util
+// Ryan Kelley <kelleyry@bc.edu>
+// vanRijn <j_dot_kasper@usa.net>
+// check http://movingparts.windsofstorm.net for more bbkeys info
+// licensed under the GPL
+
+#include "myapplication.hh"
+#include <qwindowsstyle.h>
+
+#include "gui.hh"
+
+int main( int argc, char **argv )
+{
+  QApplication::setStyle( new QWindowsStyle());
+  MyApplication bbkeysCfg( argc, argv );
+
+  FrontEnd *fe = new FrontEnd( 0, "FrontEnd" );
+
+  bbkeysCfg.setMainWidget( fe );
+  fe->show();
+
+  return bbkeysCfg.exec();
+}
+
diff -urN bbkeys-0.3.2/data/Makefile.in.orig bbkeys-0.3.2-nyz/data/Makefile.in.orig
--- bbkeys-0.3.2/data/Makefile.in.orig	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/data/Makefile.in.orig	Sat Apr  8 13:50:59 2000
@@ -0,0 +1,198 @@
+# Makefile.in generated automatically by automake 1.4 from Makefile.am
+
+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = @SHELL@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DESTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+CC = @CC@
+CXX = @CXX@
+INTERLACE = @INTERLACE@
+MAKEINFO = @MAKEINFO@
+PACKAGE = @PACKAGE@
+VERSION = @VERSION@
+regex_cmd = @regex_cmd@
+
+configdir = $(datadir)/bbtools
+
+config_DATA = bbkeys.bb 		bbkeys.nobb 		README.bbkeys
+
+
+EXTRA_DIST = $(config_DATA)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_CLEAN_FILES = 
+DATA =  $(config_DATA)
+
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP_ENV = --best
+all: all-redirect
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOMAKE) --gnu --include-deps data/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+install-configDATA: $(config_DATA)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(configdir)
+	@list='$(config_DATA)'; for p in $$list; do \
+	  if test -f $(srcdir)/$$p; then \
+	    echo " $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(configdir)/$$p"; \
+	    $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(configdir)/$$p; \
+	  else if test -f $$p; then \
+	    echo " $(INSTALL_DATA) $$p $(DESTDIR)$(configdir)/$$p"; \
+	    $(INSTALL_DATA) $$p $(DESTDIR)$(configdir)/$$p; \
+	  fi; fi; \
+	done
+
+uninstall-configDATA:
+	@$(NORMAL_UNINSTALL)
+	list='$(config_DATA)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(configdir)/$$p; \
+	done
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = data
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  if test -d $$d/$$file; then \
+	    cp -pr $$d/$$file $(distdir)/$$file; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	    || cp -p $$d/$$file $(distdir)/$$file || :; \
+	  fi; \
+	done
+info-am:
+info: info-am
+dvi-am:
+dvi: dvi-am
+check-am: all-am
+check: check-am
+installcheck-am:
+installcheck: installcheck-am
+install-exec-am:
+install-exec: install-exec-am
+
+install-data-am: install-configDATA
+install-data: install-data-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+install: install-am
+uninstall-am: uninstall-configDATA
+uninstall: uninstall-am
+all-am: Makefile $(DATA) all-local
+all-redirect: all-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
+installdirs:
+	$(mkinstalldirs)  $(DESTDIR)$(configdir)
+
+
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+mostlyclean-am:  mostlyclean-generic
+
+mostlyclean: mostlyclean-am
+
+clean-am:  clean-generic mostlyclean-am
+
+clean: clean-am
+
+distclean-am:  distclean-generic clean-am
+
+distclean: distclean-am
+
+maintainer-clean-am:  maintainer-clean-generic distclean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+maintainer-clean: maintainer-clean-am
+
+.PHONY: uninstall-configDATA install-configDATA tags distdir info-am \
+info dvi-am dvi check check-am installcheck-am installcheck \
+install-exec-am install-exec install-data-am install-data install-am \
+install uninstall-am uninstall all-local all-redirect all-am all \
+installdirs mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+all-local:
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN bbkeys-0.3.2/data/Makefile.in.rej bbkeys-0.3.2-nyz/data/Makefile.in.rej
--- bbkeys-0.3.2/data/Makefile.in.rej	Wed Dec 31 18:00:00 1969
+++ bbkeys-0.3.2-nyz/data/Makefile.in.rej	Wed May 10 22:58:51 2000
@@ -0,0 +1,51 @@
+***************
+*** 80,93 ****
+  
+  DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+  
+- TAR = gtar
+  GZIP_ENV = --best
+  all: all-redirect
+  .SUFFIXES:
+  $(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) 
+- 	cd $(top_srcdir) && $(AUTOMAKE) --gnu data/Makefile
+  
+- Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status $(BUILT_SOURCES)
+  	cd $(top_builddir) \
+  	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+  
+--- 80,93 ----
+  
+  DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+  
++ TAR = tar
+  GZIP_ENV = --best
+  all: all-redirect
+  .SUFFIXES:
+  $(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) 
++ 	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps data/Makefile
+  
++ Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+  	cd $(top_builddir) \
+  	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+  
+***************
+*** 119,129 ****
+  subdir = data
+  
+  distdir: $(DISTFILES)
+- 	here=`cd $(top_builddir) && pwd`; \
+- 	top_distdir=`cd $(top_distdir) && pwd`; \
+- 	distdir=`cd $(distdir) && pwd`; \
+- 	cd $(top_srcdir) \
+- 	  && $(AUTOMAKE) --include-deps --build-dir=$$here --srcdir-name=$(top_srcdir) --output-dir=$$top_distdir --gnu data/Makefile
+  	@for file in $(DISTFILES); do \
+  	  d=$(srcdir); \
+  	  if test -d $$d/$$file; then \
+--- 119,124 ----
+  subdir = data
+  
+  distdir: $(DISTFILES)
+  	@for file in $(DISTFILES); do \
+  	  d=$(srcdir); \
+  	  if test -d $$d/$$file; then \
diff -urN bbkeys-0.3.2/wminterface.cc bbkeys-0.3.2-nyz/wminterface.cc
--- bbkeys-0.3.2/wminterface.cc	Sat Apr  8 12:15:50 2000
+++ bbkeys-0.3.2-nyz/wminterface.cc	Wed May 10 22:58:51 2000
@@ -54,7 +54,7 @@
 void WMInterface::changeDesktop(int desk_number) {
   unsigned long int data=desk_number;
 
-  sendClientMessage(bbtool->getNETChangeWorkspaceAtom(),data);
+  sendClientMessage(bbtool->getBlackboxChangeWorkspaceAtom(),data);
 }
 
 
@@ -64,9 +64,9 @@
 
   e.xclient.type = ClientMessage;
   e.xclient.window = win;
-  e.xclient.message_type = bbtool->getNETChangeAttributesAtom();
+  e.xclient.message_type = bbtool->getBlackboxChangeAttributesAtom();
   e.xclient.format = 32;
-  e.xclient.data.l[0] = NETAttribWorkspace;
+  e.xclient.data.l[0] = AttribWorkspace;
   e.xclient.data.l[1] = 0;
   e.xclient.data.l[2] = desk_number;
   e.xclient.data.l[3] = 0; 
@@ -87,7 +87,7 @@
   e.xclient.type = ClientMessage;
   e.xclient.window =  win;
 
-  e.xclient.message_type = bbtool->getNETChangeWindowFocusAtom();
+  e.xclient.message_type = bbtool->getBlackboxChangeWindowFocusAtom();
   e.xclient.format = 32;
   e.xclient.data.l[0] = 0;
   e.xclient.data.l[1] = 0;
@@ -126,8 +126,8 @@
 
   
   status = XGetWindowProperty(bbtool->getXDisplay(), win, 
-                              bbtool->getNETAttributesAtom(), 0L, 1L,
-                              False, bbtool->getNETAttributesAtom(), 
+                              bbtool->getBlackboxAttributesAtom(), 0L, 1L,
+                              False, bbtool->getBlackboxAttributesAtom(), 
                               &real_type, &format,&n, &extra,  
                               (unsigned char**)&p);
   if (!status) {
@@ -199,7 +199,7 @@
     status=isIconicState(tmp->win);
 
     if (status==-1) return;
-    if (status&NETAttribOmnipresent) {
+    if (status&AttribOmnipresent) {
       if (!tmp->sticky) {
         XUnmapWindow(bbtool->getXDisplay(),tmp->pager_win);
         tmp->icon=True;
@@ -252,7 +252,7 @@
 
     if (status==-1) return;
       
-    if (status&NETAttribOmnipresent) {
+    if (status&AttribOmnipresent) {
       if (!tmp->sticky) {
         addSticky(tmp);
         tmp->sticky=True;
@@ -263,7 +263,7 @@
       tmp->sticky=False;
     }
     
-    if (status&NETAttribShaded ) {
+    if (status&AttribShaded ) {
       if (!tmp->shaded) {
         tmp->pager_height=2;
         XResizeWindow(bbtool->getXDisplay(),tmp->pager_win,tmp->pager_width,
@@ -305,7 +305,7 @@
     if (tmp->desktop_nr>=0) {
       bbtool->addFrameWindow(tmp,0,False);
       bbtool->windowList->insert(tmp);
-      if (getAttributes(tmp->win)&NETAttribOmnipresent)
+      if (getAttributes(tmp->win)&AttribOmnipresent)
         addSticky(tmp);
     }
     else delete tmp;
